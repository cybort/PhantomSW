<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SystemCLanguage: sysc/utils/sc_temporary.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>sysc/utils/sc_temporary.h</h1><a href="a00398.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or</span>
<a name="l00004"></a>00004 <span class="comment">  more contributor license agreements.  See the NOTICE file distributed</span>
<a name="l00005"></a>00005 <span class="comment">  with this work for additional information regarding copyright ownership.</span>
<a name="l00006"></a>00006 <span class="comment">  Accellera licenses this file to you under the Apache License, Version 2.0</span>
<a name="l00007"></a>00007 <span class="comment">  (the &quot;License&quot;); you may not use this file except in compliance with the</span>
<a name="l00008"></a>00008 <span class="comment">  License.  You may obtain a copy of the License at</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">  Unless required by applicable law or agreed to in writing, software</span>
<a name="l00013"></a>00013 <span class="comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<a name="l00014"></a>00014 <span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or</span>
<a name="l00015"></a>00015 <span class="comment">  implied.  See the License for the specific language governing</span>
<a name="l00016"></a>00016 <span class="comment">  permissions and limitations under the License.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment"> *****************************************************************************/</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/*****************************************************************************</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">  sc_temporary.h -- Temporary value pool classes.</span>
<a name="l00023"></a>00023 <span class="comment"></span>
<a name="l00024"></a>00024 <span class="comment">  Original Author: Andy Goodrich, Forte Design Systems, Inc.</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">  CHANGE LOG AT END OF FILE</span>
<a name="l00027"></a>00027 <span class="comment"> *****************************************************************************/</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#ifndef SC_TEMPORARY_H</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#define SC_TEMPORARY_H</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="a00343.html">sysc/kernel/sc_cmnhdr.h</a>&quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;cstddef&gt;</span>                <span class="comment">// std::size_t</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">namespace </span>sc_core {
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00038"></a>00038 <span class="comment">// sc_byte_heap - CLASS MANAGING A TEMPORARY HEAP OF BYTES</span>
<a name="l00039"></a>00039 <span class="comment">//</span>
<a name="l00040"></a>00040 <span class="comment">// This facility implements a heap of temporary byte allocations. Once an </span>
<a name="l00041"></a>00041 <span class="comment">// request has been allocated it is not freed. However the entire heap </span>
<a name="l00042"></a>00042 <span class="comment">// wraps and the storage is reused. This means that no allocations should</span>
<a name="l00043"></a>00043 <span class="comment">// be assumed as permanent. Allocations are double-word aligned. This is</span>
<a name="l00044"></a>00044 <span class="comment">// raw storage, so objects which contain virtual methods cannot be allocated</span>
<a name="l00045"></a>00045 <span class="comment">// with this object. See the sc_vpool object for that type of storage </span>
<a name="l00046"></a>00046 <span class="comment">// allocation.</span>
<a name="l00047"></a>00047 <span class="comment">//</span>
<a name="l00048"></a>00048 <span class="comment">// char* allocate( int size )</span>
<a name="l00049"></a>00049 <span class="comment">//   This method returns a pointer to block of size bytes. The block</span>
<a name="l00050"></a>00050 <span class="comment">//   returned is the next available one in the heap. If the current heap</span>
<a name="l00051"></a>00051 <span class="comment">//   cannot fullfil the request it will be rewound and storage allocated from</span>
<a name="l00052"></a>00052 <span class="comment">//   its start. All allocations start on an 8-byte boundary.</span>
<a name="l00053"></a>00053 <span class="comment">//       size = number of bytes to be allocated.</span>
<a name="l00054"></a>00054 <span class="comment">//</span>
<a name="l00055"></a>00055 <span class="comment">// void initialize( int heap_size=0x100000 )</span>
<a name="l00056"></a>00056 <span class="comment">//   This method allocates the storage to be managed. If there is already</span>
<a name="l00057"></a>00057 <span class="comment">//   a block of storage under management it is freed. If no argument is</span>
<a name="l00058"></a>00058 <span class="comment">//   provided for the heap size, a megabyte will be allocated.</span>
<a name="l00059"></a>00059 <span class="comment">//       heap_size = number of bytes to allocate for the heap.</span>
<a name="l00060"></a>00060 <span class="comment">//</span>
<a name="l00061"></a>00061 <span class="comment">// unsigned int length()</span>
<a name="l00062"></a>00062 <span class="comment">//   This method returns the size of this object&apos;s heap in bytes.</span>
<a name="l00063"></a>00063 <span class="comment">//</span>
<a name="l00064"></a>00064 <span class="comment">// sc_byte_heap()</span>
<a name="l00065"></a>00065 <span class="comment">//   This is the non-initialized object instance constructor. It does not </span>
<a name="l00066"></a>00066 <span class="comment">//   allocate the heap storage, that is done by the initialize() method.</span>
<a name="l00067"></a>00067 <span class="comment">//</span>
<a name="l00068"></a>00068 <span class="comment">// sc_byte_heap(int)</span>
<a name="l00069"></a>00069 <span class="comment">//   This is the initializing object instance constructor. It does allocates</span>
<a name="l00070"></a>00070 <span class="comment">//   a heap of the specified number of bytes.</span>
<a name="l00071"></a>00071 <span class="comment">//       heap_size = number of bytes to allocate for the heap.</span>
<a name="l00072"></a>00072 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00073"></a><a class="code" href="a00032.html">00073</a> <span class="keyword">class </span><a class="code" href="a00343.html#aff4a86b3f5de3ac2097081e7166fe89f">SC_API</a> <a class="code" href="a00032.html">sc_byte_heap</a> {
<a name="l00074"></a>00074   <span class="keyword">public</span>:
<a name="l00075"></a><a class="code" href="a00032.html#a6757df0d85349d0cca958c6e4c5f41c6">00075</a>     <span class="keywordtype">char</span>*  m_bgn_p;  <span class="comment">// Beginning of heap storage.</span>
<a name="l00076"></a><a class="code" href="a00032.html#a284a566947570fb7b361eb729d76a24f">00076</a>     <span class="keywordtype">char</span>*  m_end_p;  <span class="comment">// End of heap storage.</span>
<a name="l00077"></a><a class="code" href="a00032.html#a98195d5afe037a3aea9a9b3305019b60">00077</a>     <span class="keywordtype">char</span>*  m_next_p; <span class="comment">// Next heap location to be allocated.</span>
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="a00032.html#a788d2eb4ab139406ae8cecf9ddc54a67">00079</a>     <span class="keyword">inline</span> <span class="keywordtype">char</span>* allocate( std::size_t bytes_n )
<a name="l00080"></a>00080     {
<a name="l00081"></a>00081         <span class="keywordtype">char</span>*   result_p;
<a name="l00082"></a>00082         bytes_n = (bytes_n + 7) &amp; ((std::size_t)(-8));
<a name="l00083"></a>00083         result_p = m_next_p;
<a name="l00084"></a>00084         m_next_p += bytes_n;
<a name="l00085"></a>00085         <span class="keywordflow">if</span> ( m_next_p &gt;= m_end_p )
<a name="l00086"></a>00086         {
<a name="l00087"></a>00087             result_p = m_bgn_p;
<a name="l00088"></a>00088             m_next_p = m_bgn_p + bytes_n;
<a name="l00089"></a>00089         }
<a name="l00090"></a>00090         <span class="keywordflow">return</span> result_p; 
<a name="l00091"></a>00091     }
<a name="l00092"></a>00092 
<a name="l00093"></a><a class="code" href="a00032.html#a53979fc97a38e2a17f047a8cefaba0b0">00093</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> initialize( std::size_t heap_size=0x100000 )
<a name="l00094"></a>00094     {
<a name="l00095"></a>00095         <span class="keyword">delete</span> [] m_bgn_p;
<a name="l00096"></a>00096         m_bgn_p = <span class="keyword">new</span> <span class="keywordtype">char</span>[heap_size];
<a name="l00097"></a>00097         m_end_p = &amp;m_bgn_p[heap_size];
<a name="l00098"></a>00098         m_next_p = m_bgn_p;
<a name="l00099"></a>00099     }
<a name="l00100"></a>00100 
<a name="l00101"></a><a class="code" href="a00032.html#a7fac0b24516bd925e4eac0a2bcb13f00">00101</a>         <span class="keyword">inline</span> std::size_t length()
<a name="l00102"></a>00102         {
<a name="l00103"></a>00103                 <span class="keywordflow">return</span> (std::size_t)(m_end_p - m_bgn_p);
<a name="l00104"></a>00104         }
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="a00032.html#a05c784aa054dfca5cded5b533262dddc">00106</a>         <span class="keyword">inline</span> <a class="code" href="a00032.html">sc_byte_heap</a>() : 
<a name="l00107"></a>00107             m_bgn_p(0), m_end_p(0), m_next_p(0)
<a name="l00108"></a>00108         {
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110 
<a name="l00111"></a><a class="code" href="a00032.html#ab804a187058af80cf0deebde1b4e1b69">00111</a>                 <span class="keyword">inline</span> <a class="code" href="a00032.html">sc_byte_heap</a>( std::size_t heap_size ) :
<a name="l00112"></a>00112             m_bgn_p(0), m_end_p(0), m_next_p(0)
<a name="l00113"></a>00113         {
<a name="l00114"></a>00114                 initialize( heap_size );
<a name="l00115"></a>00115         }
<a name="l00116"></a>00116 
<a name="l00117"></a><a class="code" href="a00032.html#ac744e67b73a4efd878594f14bcf98712">00117</a>         <span class="keyword">inline</span> ~<a class="code" href="a00032.html">sc_byte_heap</a>()
<a name="l00118"></a>00118         {
<a name="l00119"></a>00119                 <span class="keyword">delete</span> [] m_bgn_p;
<a name="l00120"></a>00120         }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 };
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00126"></a>00126 <span class="comment">// sc_vpool&lt;T&gt; - CLASS MANAGING A TEMPORARY VECTOR OF CLASS T INSTANCES</span>
<a name="l00127"></a>00127 <span class="comment">//</span>
<a name="l00128"></a>00128 <span class="comment">// This class implements a fixed pool of objects contained in a vector. These</span>
<a name="l00129"></a>00129 <span class="comment">// objects are allocated via the allocate() method. An index, m_pool_i, </span>
<a name="l00130"></a>00130 <span class="comment">// indicates the next object to be allocated. The vector is a power of 2 in</span>
<a name="l00131"></a>00131 <span class="comment">// size, and this fact is used to wrap the list when m_pool_i reaches the</span>
<a name="l00132"></a>00132 <span class="comment">// end of the vector.  </span>
<a name="l00133"></a>00133 <span class="comment">// </span>
<a name="l00134"></a>00134 <span class="comment">// sc_vpool( int log2, T* pool_p=0 )</span>
<a name="l00135"></a>00135 <span class="comment">//   This is the object instance constructor for this class. It configures</span>
<a name="l00136"></a>00136 <span class="comment">//   the object to manage a vector of 2**log2 entries. If a vector is </span>
<a name="l00137"></a>00137 <span class="comment">//   not supplied one will be allocated.</span>
<a name="l00138"></a>00138 <span class="comment">//     log2   =  the log base two of the size of the vector.</span>
<a name="l00139"></a>00139 <span class="comment">//     pool_p -&gt; vector of 2**log2 entries to be managed or 0.</span>
<a name="l00140"></a>00140 <span class="comment">//</span>
<a name="l00141"></a>00141 <span class="comment">// ~sc_vpool()</span>
<a name="l00142"></a>00142 <span class="comment">//   This is the object instance destructor for this class. It frees the</span>
<a name="l00143"></a>00143 <span class="comment">//   block of storage which was being managed.</span>
<a name="l00144"></a>00144 <span class="comment">//</span>
<a name="l00145"></a>00145 <span class="comment">// T* allocate()</span>
<a name="l00146"></a>00146 <span class="comment">//   This method returns the address of the next entry in the vector, m_pool_p, </span>
<a name="l00147"></a>00147 <span class="comment">//   pointed to by the index, m_pool_i, and updates that index. The index</span>
<a name="l00148"></a>00148 <span class="comment">//   update consists of adding 1 to m_pool_i and masking it by m_wrap.</span>
<a name="l00149"></a>00149 <span class="comment">// </span>
<a name="l00150"></a>00150 <span class="comment">// void reset()</span>
<a name="l00151"></a>00151 <span class="comment">//   This method resets the allocation index, m_pool_i, to point to the start</span>
<a name="l00152"></a>00152 <span class="comment">//   of the vector of objects under management. This call is not usually made</span>
<a name="l00153"></a>00153 <span class="comment">//   since there are a fixed number of entries and the index wraps. However,</span>
<a name="l00154"></a>00154 <span class="comment">//   for diagnostics tests it is convenient to be able to reset to the start</span>
<a name="l00155"></a>00155 <span class="comment">//   of the vector.</span>
<a name="l00156"></a>00156 <span class="comment">//</span>
<a name="l00157"></a>00157 <span class="comment">// int size()</span>
<a name="l00158"></a>00158 <span class="comment">//   This method returns the number of object instances contained in the</span>
<a name="l00159"></a>00159 <span class="comment">//   vector being managed by this object instance.</span>
<a name="l00160"></a>00160 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00161"></a>00161 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00162"></a><a class="code" href="a00243.html">00162</a> <span class="keyword">class </span><a class="code" href="a00243.html">sc_vpool</a> {
<a name="l00163"></a>00163   <span class="keyword">protected</span>:
<a name="l00164"></a><a class="code" href="a00243.html#aff7eb7691b1e8db15af19b9459123617">00164</a>         std::size_t <a class="code" href="a00243.html#aff7eb7691b1e8db15af19b9459123617">m_pool_i</a>;   <span class="comment">// Index of next entry to m_pool_m to provide.</span>
<a name="l00165"></a><a class="code" href="a00243.html#a11d0b4c4b790137c9d1df6848f9dfb40">00165</a>         T*          <a class="code" href="a00243.html#a11d0b4c4b790137c9d1df6848f9dfb40">m_pool_p</a>;   <span class="comment">// Vector of temporaries.</span>
<a name="l00166"></a><a class="code" href="a00243.html#a430f408c8db8337106d2aeed41196812">00166</a>         std::size_t <a class="code" href="a00243.html#a430f408c8db8337106d2aeed41196812">m_wrap</a>;             <span class="comment">// Mask to wrap vector index.</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="keyword">public</span>:
<a name="l00169"></a>00169         <span class="keyword">inline</span> <a class="code" href="a00243.html#ab5b01e7b12d2de407ae96b91814c12a4">sc_vpool</a>( <span class="keywordtype">int</span> log2, T* pool_p=0 );
<a name="l00170"></a>00170         <span class="keyword">inline</span> <a class="code" href="a00243.html#aa486fedc6c53b748dfdc26e155c6bb9a">~sc_vpool</a>();
<a name="l00171"></a>00171         <span class="keyword">inline</span> T* <a class="code" href="a00243.html#ada12261afe8aa7bf0051594e77442ee8">allocate</a>();
<a name="l00172"></a>00172         <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00243.html#ab569f89ce8f7f8395ad8451b844e8533">reset</a>();
<a name="l00173"></a>00173         <span class="keyword">inline</span> std::size_t <a class="code" href="a00243.html#a7605175ea69c4e71edf85467f42b7a71">size</a>();
<a name="l00174"></a>00174 };
<a name="l00175"></a>00175 
<a name="l00176"></a><a class="code" href="a00243.html#ab5b01e7b12d2de407ae96b91814c12a4">00176</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <a class="code" href="a00243.html#ab5b01e7b12d2de407ae96b91814c12a4">sc_vpool&lt;T&gt;::sc_vpool</a>( <span class="keywordtype">int</span> log2, T* pool_p )
<a name="l00177"></a>00177   : m_pool_i( 0 )
<a name="l00178"></a>00178   , m_pool_p( pool_p ? pool_p : new T[static_cast&lt;std::size_t&gt;(1) &lt;&lt; log2] )
<a name="l00179"></a>00179   , m_wrap( ~(static_cast&lt;std::size_t&gt;(-1) &lt;&lt; log2) )
<a name="l00180"></a>00180 {
<a name="l00181"></a>00181         <span class="comment">// if ( log2 &gt; 32 ) SC_REPORT_ERROR(SC_ID_POOL_SIZE_, &quot;&quot;);</span>
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00184"></a><a class="code" href="a00243.html#aa486fedc6c53b748dfdc26e155c6bb9a">00184</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <a class="code" href="a00243.html#aa486fedc6c53b748dfdc26e155c6bb9a">sc_vpool&lt;T&gt;::~sc_vpool</a>()
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186         <span class="comment">// delete [] m_pool_p;</span>
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a><a class="code" href="a00243.html#ada12261afe8aa7bf0051594e77442ee8">00189</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; T* <a class="code" href="a00243.html#ada12261afe8aa7bf0051594e77442ee8">sc_vpool&lt;T&gt;::allocate</a>()
<a name="l00190"></a>00190 {
<a name="l00191"></a>00191         T* result_p;    <span class="comment">// Entry to return.</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         result_p = &amp;<a class="code" href="a00243.html#a11d0b4c4b790137c9d1df6848f9dfb40">m_pool_p</a>[<a class="code" href="a00243.html#aff7eb7691b1e8db15af19b9459123617">m_pool_i</a>];
<a name="l00194"></a>00194         <a class="code" href="a00243.html#aff7eb7691b1e8db15af19b9459123617">m_pool_i</a> = (<a class="code" href="a00243.html#aff7eb7691b1e8db15af19b9459123617">m_pool_i</a> + 1) &amp; <a class="code" href="a00243.html#a430f408c8db8337106d2aeed41196812">m_wrap</a>;
<a name="l00195"></a>00195         <span class="keywordflow">return</span> result_p;
<a name="l00196"></a>00196 }
<a name="l00197"></a>00197 
<a name="l00198"></a><a class="code" href="a00243.html#ab569f89ce8f7f8395ad8451b844e8533">00198</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="a00243.html#ab569f89ce8f7f8395ad8451b844e8533">sc_vpool&lt;T&gt;::reset</a>()
<a name="l00199"></a>00199 {
<a name="l00200"></a>00200         <a class="code" href="a00243.html#aff7eb7691b1e8db15af19b9459123617">m_pool_i</a> = 0;
<a name="l00201"></a>00201 }
<a name="l00202"></a>00202 
<a name="l00203"></a><a class="code" href="a00243.html#a7605175ea69c4e71edf85467f42b7a71">00203</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; std::size_t <a class="code" href="a00243.html#a7605175ea69c4e71edf85467f42b7a71">sc_vpool&lt;T&gt;::size</a>()
<a name="l00204"></a>00204 {
<a name="l00205"></a>00205         <span class="keywordflow">return</span> <a class="code" href="a00243.html#a430f408c8db8337106d2aeed41196812">m_wrap</a> + 1;
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 } <span class="comment">// namespace sc_core</span>
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="comment">// $Log: sc_temporary.h,v $</span>
<a name="l00211"></a>00211 <span class="comment">// Revision 1.4  2011/08/26 20:46:19  acg</span>
<a name="l00212"></a>00212 <span class="comment">//  Andy Goodrich: moved the modification log to the end of the file to</span>
<a name="l00213"></a>00213 <span class="comment">//  eliminate source line number skew when check-ins are done.</span>
<a name="l00214"></a>00214 <span class="comment">//</span>
<a name="l00215"></a>00215 <span class="comment">// Revision 1.3  2011/08/24 22:05:56  acg</span>
<a name="l00216"></a>00216 <span class="comment">//  Torsten Maehne: initialization changes to remove warnings.</span>
<a name="l00217"></a>00217 <span class="comment">//</span>
<a name="l00218"></a>00218 <span class="comment">// Revision 1.2  2011/02/18 20:38:44  acg</span>
<a name="l00219"></a>00219 <span class="comment">//  Andy Goodrich: Updated Copyright notice.</span>
<a name="l00220"></a>00220 <span class="comment">//</span>
<a name="l00221"></a>00221 <span class="comment">// Revision 1.1.1.1  2006/12/15 20:20:06  acg</span>
<a name="l00222"></a>00222 <span class="comment">// SystemC 2.3</span>
<a name="l00223"></a>00223 <span class="comment">//</span>
<a name="l00224"></a>00224 <span class="comment">// Revision 1.3  2006/01/13 18:53:11  acg</span>
<a name="l00225"></a>00225 <span class="comment">// Andy Goodrich: Added $Log command so that CVS comments are reproduced in</span>
<a name="l00226"></a>00226 <span class="comment">// the source.</span>
<a name="l00227"></a>00227 <span class="comment">//</span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="preprocessor">#endif // SC_TEMPORARY_H</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 10 Dec 2020 for SystemCLanguage by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
